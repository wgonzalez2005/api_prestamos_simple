
https://nodejs.org/en/
https://docs.nestjs.com/
https://github.com/angeldelacruzdev/nestjs-jwt-typeorm-sql
npm i -g @nestjs/cli
/*Configuracion*/
npm i --save @nestjs/config

/*Seguridad*/
npm i bcrypt
npm i -D @types/bcrypt

/*Helmut*/
npm i --save helmet

/*VALIDADOR*/
npm i --save class-validator class-transformer

.env
PORT=5000 
ORIGIN=http://127.0.0.1/
DATABASE_HOST=localhost
DATABASE_PORT=3306
DATABASE_USER=root
DATABASE_PASSWORD=
DATABASE_DB=db_appinfotep

old: $2b$10$ttAAexku6Yinbk8qsu9WcO0z1aTa..QzIlsgOXnt7jrhxVc9NGWle
new: $2b$10$wghv13BGgj1qMAmVeUYyP.Ek9YaxKV2sTbC472TZNe9p67QbQMRtO

/*Crear Modulo*/
 nest g resource

/*Modulo principal*/
imports: [ConfigModule.forRoot({
    isGlobal: true,
  }),

/*DATA BASE*/
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
 
@Module({
  imports: [
    TypeOrmModule.forRootAsync({
      useFactory: () => ({
        type: 'mysql',
        host: process.env.DATABASE_HOST,
        port: parseInt(process.env.DATABASE_PORT),
        username: process.env.DATABASE_USER,
        password: process.env.DATABASE_PASSWORD || '',
        database: process.env.DATABASE_DB,
        synchronize: true,
      }),
    })
  ],
})
export class DatabaseModule {}
/****************MAIN***********************/

 app.use(
    helmet({
      crossOriginResourcePolicy: false,
      hidePoweredBy: true,
    }),
  );
 
 app.useGlobalPipes(new ValidationPipe());

 app.enableCors({
    origin:process.env.ORIGIN
  });

  await app.listen(process.env.PORT);


/*******************************************************/
constructor(private dataSource: EntityManager) {}
 try {
      const result = await this.dataSource.query('call web_getGaleriasAll()');
      return result.find((e: any) => e !== undefined) || [];
    } catch (error) {
      console.log(error);
    }


/*******************************************************/
async

 try {
      const hash = await this.hashPassword(createUserDto.contra);

      let saveUser = await this.dataSource.query(
        'call web_InsertarUsuarios(?,?,?,?)',
        [0, createUserDto.nomb, createUserDto.cue, hash],
      );

      return saveUser[0];
    } catch (error) {
      console.log(error);
    }
try {
      let usuario = await this.dataSource.query('call web_findByCuenta(?)', [
        cuenta,
      ]);
      const result = usuario.find((e: any) => e !== undefined) || [];
      return result[0];
    } catch (error) {
      console.log(error);
    }
 try {
      let usuario = await this.dataSource.query('call web_findByCuenta(?)', [
        cuenta,
      ]);
      const result = usuario.find((e: any) => e !== undefined) || [];
      return result[0];
    } catch (error) {
      console.log(error);
    }
 try {
      const hash = await this.hashPassword(updateUserDto.contra);

      let saveUser = await this.dataSource.query(
        'call web_InsertarUsuarios(?,?,?,?)',
        [id, updateUserDto.nomb, updateUserDto.cue, hash],
      );

      return saveUser;
    } catch (error) {
      console.log(error);
    }
try {
      let eliminaUsuario = await this.dataSource.query(
        'call web_deleteUsuarios(?)',
        [id],
      );
      return eliminaUsuario[0];
    } catch (error) {
      console.log(error);
    }

 async busqueda(q: string) {
    try {
      const result = await this.dataSource.query(
        'call web_getBuscarUsuarios(?)',
        [`%${q}%`],
      );
      return result.find((e: any) => e !== undefined) || [];
    } catch (error) {
      console.log(error);
      return;
    }
  }


 @Get('data/busqueda')
  async busqueda(@Query() { q }: { q: string }) {
    return await this.usersService.busqueda(q);
  }

 async hashPassword(password: string) {
    const saltOrRounds = 10;
    const hash = await bcrypt.hash(password, saltOrRounds);
    return hash;
  }


import * as bcrypt from 'bcrypt';
async findOneByCuenta(cuenta: string) {
    try {
      let usuario = await this.dataSource.query('call web_findByCuenta(?)', [
        cuenta,
      ]);
      const result = usuario.find((e: any) => e !== undefined) || [];
      return result[0];
    } catch (error) {
      console.log(error);
    }
  }

/*Constructor de la base de datos va en el servicio*/
constructor(private dataSource: EntityManager) {}


//                LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);
//                AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this);
//                final View mView4 = inflater.inflate(R.layout.opciones, null);
//                RadioButton op1 = mView4.findViewById(R.id.usuario);
//                RadioButton op2 = mView4.findViewById(R.id.cos);
//                RadioButton op3 = mView4.findViewById(R.id.infotep);
//
//                builder.setPositiveButton("Aceptar",
//                        new DialogInterface.OnClickListener() {
//                            @Override
//                            public void onClick(DialogInterface dialog, int which) {
//                                if(op1.isChecked()){
//                                    intent = new Intent(MainActivity.this, usuarios.class);
//                                    startActivity(intent);
//                                }else if(op2.isChecked()){
//                                    intent = new Intent(MainActivity.this, cos.class);
//                                    startActivity(intent);
//                                } else if(op3.isChecked()){
//                                    intent = new Intent(MainActivity.this, infotep.class);
//                                    startActivity(intent);
//                                }
//                                dialog.dismiss();
//                            }
//                        });
//                builder.setView(mView4);
//                AlertDialog dialog4 = builder.create();
//                dialog4.show();
